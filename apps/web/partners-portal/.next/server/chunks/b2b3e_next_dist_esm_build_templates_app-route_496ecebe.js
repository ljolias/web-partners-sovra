module.exports=[11244,e=>{"use strict";var t=e.i(72305),o=e.i(89013),a=e.i(88387),r=e.i(77950),i=e.i(30739),n=e.i(43703),l=e.i(58601),s=e.i(59251),d=e.i(12242),c=e.i(6002),u=e.i(92234),h=e.i(45043),v=e.i(18348),p=e.i(85936),g=e.i(72254),m=e.i(93695);e.i(24887);var I=e.i(42277),f=e.i(34550);e.i(4287);var b=e.i(31967);e.i(29347);var w=e.i(48284);async function S(e){try{let t;console.log("[SovraID Webhook] Received request");let o=await e.text();console.log("[SovraID Webhook] Raw body:",o);try{t=JSON.parse(o)}catch(e){return console.error("[SovraID Webhook] Failed to parse body:",e),f.NextResponse.json({error:"Invalid JSON"},{status:400})}console.log("[SovraID Webhook] Event type:",t.eventType),console.log("[SovraID Webhook] Event data:",JSON.stringify(t.eventData,null,2));let a=process.env.SOVRAID_WEBHOOK_SECRET;if(a){let t=e.headers.get("authorization"),o=e.headers.get("x-sovraid-signature")||e.headers.get("x-webhook-secret")||(t?.startsWith("Bearer ")?t.slice(7):t);console.log("[SovraID Webhook] Checking authentication..."),o!==a&&console.warn("[SovraID Webhook] Signature mismatch - continuing for debugging")}switch(t.eventType){case"credential-issued":await D(t.eventData);break;case"verifiable-presentation-finished":await k(t.eventData);break;default:console.log("[SovraID Webhook] Unhandled event type:",t.eventType)}let r=t.eventData;return r?.vc?.type?.includes("TrainingCertification")&&await y(r),f.NextResponse.json({received:!0})}catch(e){return console.error("[SovraID Webhook] Error processing webhook:",e),f.NextResponse.json({error:"Webhook processing failed"},{status:500})}}async function D(e){let{holderDID:t,invitationId:o,vc:a}=e;console.log("[SovraID Webhook] Processing credential-issued"),console.log("[SovraID Webhook] Holder DID:",t),console.log("[SovraID Webhook] Invitation ID:",o);let r=await R(o,e);if(!r)return void console.warn("[SovraID Webhook] Credential not found for invitation ID:",o);let i=new Date().toISOString(),n=await (0,b.getUserByEmail)(r.holderEmail),l=n?.id;if(n)console.log("[SovraID Webhook] User already exists:",n.id);else{console.log("[SovraID Webhook] Creating user account for:",r.holderEmail);let e={id:l=(0,b.generateId)(),partnerId:r.partnerId,email:r.holderEmail,name:r.holderName,role:r.role,passwordHash:"",createdAt:i,updatedAt:i};await (0,b.createUser)(e),console.log("[SovraID Webhook] User account created:",l),await (0,b.addAuditLog)("user.created","user",l,{id:"system",name:"SovraID Webhook",type:"system"},{entityName:r.holderName,metadata:{partnerId:r.partnerId,email:r.holderEmail,role:r.role,createdViaCredentialClaim:!0}})}await (0,b.updatePartnerCredential)(r.id,{status:"active",claimedAt:i,holderDid:t,userId:l}),await (0,b.addAuditLog)("credential.claimed","credential",r.id,{id:"system",name:"SovraID Webhook",type:"system"},{entityName:r.holderName,metadata:{invitationId:o,holderDID:t,vcId:a?.id,userId:l,userCreated:!n}});let s=await (0,b.getPartner)(r.partnerId);if(s)try{await (0,w.sendWelcomeEmail)({to:r.holderEmail,holderName:r.holderName,partnerName:s.companyName})}catch(e){console.error("[SovraID Webhook] Failed to send welcome email:",e)}console.log("[SovraID Webhook] Credential activated successfully:",r.id),console.log("[SovraID Webhook] Linked to user:",l)}async function k(e){let{verified:t,holderDID:o,invitationId:a,verifiableCredentials:r}=e;console.log("[SovraID Webhook] Processing verifiable-presentation-finished"),console.log("[SovraID Webhook] Verified:",t),console.log("[SovraID Webhook] Holder DID:",o),console.log("[SovraID Webhook] Invitation ID (presentationId):",a),await (0,b.addAuditLog)("verification.completed","verification",a,{id:"system",name:"SovraID Webhook",type:"system"},{entityName:`Verification ${a}`,metadata:{verified:t,holderDID:o,credentialsCount:r?.length||0}}),console.log("[SovraID Webhook] Verification logged:",a,"verified:",t)}async function y(t){let{holderDID:o,invitationId:a}=t,{redis:r}=await e.A(13449);console.log("[SovraID Webhook] Processing TrainingCertification credential claim"),console.log("[SovraID Webhook] Invitation ID:",a);try{let e=await r.hgetall(`sovraid:invitation:${a}`);if(!e||!e.certificationId)return void console.warn("[SovraID Webhook] No training certification found for invitation:",a);let{certificationId:t,userId:i,courseId:n}=e,l=new Date().toISOString();await r.hset(`certification:${t}`,{credentialStatus:"claimed",credentialClaimedAt:l,holderDid:o}),await r.sadd("certifications:claimed",t);let s=await r.hgetall(`progress:enhanced:${i}:${n}`);s&&await r.hset(`progress:enhanced:${i}:${n}`,{...s,credentialClaimedAt:l}),await (0,b.addAuditLog)("training.credential_claimed","certification",t,{id:"system",name:"SovraID Webhook",type:"system"},{entityName:`Certification ${t}`,metadata:{invitationId:a,holderDID:o,userId:i,courseId:n,claimedAt:l}}),console.log("[SovraID Webhook] Training certification credential claimed:",t)}catch(e){console.error("[SovraID Webhook] Error handling training certification claim:",e)}}async function R(t,o){let{redis:a}=await e.A(13449),r=await a.zrange("credentials:all",0,-1);console.log("[SovraID Webhook] Searching through",r.length,"credentials");let i=o?.vc?.credentialSubject?.email,n=o?.vc?.id,l=n?.split("/").pop();for(let e of(console.log("[SovraID Webhook] Looking for invitationId:",t),console.log("[SovraID Webhook] VC email:",i),console.log("[SovraID Webhook] VC credential ID:",l),r)){let o=await a.hgetall(`credential:${e}`);if(o&&o.id){if(console.log("[SovraID Webhook] Checking credential:",{id:o.id,email:o.holderEmail,sovraIdCredentialId:o.sovraIdCredentialId,sovraIdInvitationId:o.sovraIdInvitationId}),o.sovraIdInvitationId===t)return console.log("[SovraID Webhook] Found by invitationId match"),o;if(o.sovraIdCredentialId===t||o.sovraIdCredentialId===l)return console.log("[SovraID Webhook] Found by credentialId match"),o;if(i&&o.holderEmail?.toLowerCase()===i.toLowerCase())return console.log("[SovraID Webhook] Found by email match (fallback)"),o}}return null}e.s(["POST",()=>S],86493);var C=e.i(86493);let E=new t.AppRouteRouteModule({definition:{kind:o.RouteKind.APP_ROUTE,page:"/api/sovra/webhooks/sovraid/route",pathname:"/api/sovra/webhooks/sovraid",filename:"route",bundlePath:""},distDir:".next",relativeProjectDir:"",resolvedPagePath:"[project]/apps/web/partners-portal/src/app/api/sovra/webhooks/sovraid/route.ts",nextConfigOutput:"",userland:C}),{workAsyncStorage:W,workUnitAsyncStorage:A,serverHooks:N}=E;function x(){return(0,a.patchFetch)({workAsyncStorage:W,workUnitAsyncStorage:A})}async function T(e,t,a){E.isDev&&(0,r.addRequestMeta)(e,"devRequestTimingInternalsEnd",process.hrtime.bigint());let f="/api/sovra/webhooks/sovraid/route";f=f.replace(/\/index$/,"")||"/";let b=await E.prepare(e,t,{srcPage:f,multiZoneDraftMode:!1});if(!b)return t.statusCode=400,t.end("Bad Request"),null==a.waitUntil||a.waitUntil.call(a,Promise.resolve()),null;let{buildId:w,params:S,nextConfig:D,parsedUrl:k,isDraftMode:y,prerenderManifest:R,routerServerContext:C,isOnDemandRevalidate:W,revalidateOnlyGenerated:A,resolvedPathname:N,clientReferenceManifest:x,serverActionsManifest:T}=b,O=(0,l.normalizeAppPath)(f),P=!!(R.dynamicRoutes[O]||R.routes[N]),_=async()=>((null==C?void 0:C.render404)?await C.render404(e,t,k,!1):t.end("This page could not be found"),null);if(P&&!y){let e=!!R.routes[N],t=R.dynamicRoutes[O];if(t&&!1===t.fallback&&!e){if(D.experimental.adapterPath)return await _();throw new m.NoFallbackError}}let H=null;!P||E.isDev||y||(H="/index"===(H=N)?"/":H);let U=!0===E.isDev||!P,$=P&&!U;T&&x&&(0,n.setManifestsSingleton)({page:f,clientReferenceManifest:x,serverActionsManifest:T});let q=e.method||"GET",F=(0,i.getTracer)(),L=F.getActiveScopeSpan(),M={params:S,prerenderManifest:R,renderOpts:{experimental:{authInterrupts:!!D.experimental.authInterrupts},cacheComponents:!!D.cacheComponents,supportsDynamicResponse:U,incrementalCache:(0,r.getRequestMeta)(e,"incrementalCache"),cacheLifeProfiles:D.cacheLife,waitUntil:a.waitUntil,onClose:e=>{t.on("close",e)},onAfterTaskError:void 0,onInstrumentationRequestError:(t,o,a,r)=>E.onRequestError(e,t,a,r,C)},sharedContext:{buildId:w}},j=new s.NodeNextRequest(e),V=new s.NodeNextResponse(t),K=d.NextRequestAdapter.fromNodeNextRequest(j,(0,d.signalFromNodeResponse)(t));try{let n=async e=>E.handle(K,M).finally(()=>{if(!e)return;e.setAttributes({"http.status_code":t.statusCode,"next.rsc":!1});let o=F.getRootSpanAttributes();if(!o)return;if(o.get("next.span_type")!==c.BaseServerSpan.handleRequest)return void console.warn(`Unexpected root span type '${o.get("next.span_type")}'. Please report this Next.js issue https://github.com/vercel/next.js`);let a=o.get("next.route");if(a){let t=`${q} ${a}`;e.setAttributes({"next.route":a,"http.route":a,"next.span_name":t}),e.updateName(t)}else e.updateName(`${q} ${f}`)}),l=!!(0,r.getRequestMeta)(e,"minimalMode"),s=async r=>{var i,s;let d=async({previousCacheEntry:o})=>{try{if(!l&&W&&A&&!o)return t.statusCode=404,t.setHeader("x-nextjs-cache","REVALIDATED"),t.end("This page could not be found"),null;let i=await n(r);e.fetchMetrics=M.renderOpts.fetchMetrics;let s=M.renderOpts.pendingWaitUntil;s&&a.waitUntil&&(a.waitUntil(s),s=void 0);let d=M.renderOpts.collectedTags;if(!P)return await (0,h.sendResponse)(j,V,i,M.renderOpts.pendingWaitUntil),null;{let e=await i.blob(),t=(0,v.toNodeOutgoingHttpHeaders)(i.headers);d&&(t[g.NEXT_CACHE_TAGS_HEADER]=d),!t["content-type"]&&e.type&&(t["content-type"]=e.type);let o=void 0!==M.renderOpts.collectedRevalidate&&!(M.renderOpts.collectedRevalidate>=g.INFINITE_CACHE)&&M.renderOpts.collectedRevalidate,a=void 0===M.renderOpts.collectedExpire||M.renderOpts.collectedExpire>=g.INFINITE_CACHE?void 0:M.renderOpts.collectedExpire;return{value:{kind:I.CachedRouteKind.APP_ROUTE,status:i.status,body:Buffer.from(await e.arrayBuffer()),headers:t},cacheControl:{revalidate:o,expire:a}}}}catch(t){throw(null==o?void 0:o.isStale)&&await E.onRequestError(e,t,{routerKind:"App Router",routePath:f,routeType:"route",revalidateReason:(0,u.getRevalidateReason)({isStaticGeneration:$,isOnDemandRevalidate:W})},!1,C),t}},c=await E.handleResponse({req:e,nextConfig:D,cacheKey:H,routeKind:o.RouteKind.APP_ROUTE,isFallback:!1,prerenderManifest:R,isRoutePPREnabled:!1,isOnDemandRevalidate:W,revalidateOnlyGenerated:A,responseGenerator:d,waitUntil:a.waitUntil,isMinimalMode:l});if(!P)return null;if((null==c||null==(i=c.value)?void 0:i.kind)!==I.CachedRouteKind.APP_ROUTE)throw Object.defineProperty(Error(`Invariant: app-route received invalid cache entry ${null==c||null==(s=c.value)?void 0:s.kind}`),"__NEXT_ERROR_CODE",{value:"E701",enumerable:!1,configurable:!0});l||t.setHeader("x-nextjs-cache",W?"REVALIDATED":c.isMiss?"MISS":c.isStale?"STALE":"HIT"),y&&t.setHeader("Cache-Control","private, no-cache, no-store, max-age=0, must-revalidate");let m=(0,v.fromNodeOutgoingHttpHeaders)(c.value.headers);return l&&P||m.delete(g.NEXT_CACHE_TAGS_HEADER),!c.cacheControl||t.getHeader("Cache-Control")||m.get("Cache-Control")||m.set("Cache-Control",(0,p.getCacheControlHeader)(c.cacheControl)),await (0,h.sendResponse)(j,V,new Response(c.value.body,{headers:m,status:c.value.status||200})),null};L?await s(L):await F.withPropagatedContext(e.headers,()=>F.trace(c.BaseServerSpan.handleRequest,{spanName:`${q} ${f}`,kind:i.SpanKind.SERVER,attributes:{"http.method":q,"http.target":e.url}},s))}catch(t){if(t instanceof m.NoFallbackError||await E.onRequestError(e,t,{routerKind:"App Router",routePath:O,routeType:"route",revalidateReason:(0,u.getRevalidateReason)({isStaticGeneration:$,isOnDemandRevalidate:W})},!1,C),P)throw t;return await (0,h.sendResponse)(j,V,new Response(null,{status:500})),null}}e.s(["handler",()=>T,"patchFetch",()=>x,"routeModule",()=>E,"serverHooks",()=>N,"workAsyncStorage",()=>W,"workUnitAsyncStorage",()=>A],11244)}];

//# sourceMappingURL=b2b3e_next_dist_esm_build_templates_app-route_496ecebe.js.map